// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/itihey/tikuAdapter/internal/entity"
)

func newTiku(db *gorm.DB, opts ...gen.DOOption) tiku {
	_tiku := tiku{}

	_tiku.tikuDo.UseDB(db, opts...)
	_tiku.tikuDo.UseModel(&entity.Tiku{})

	tableName := _tiku.tikuDo.TableName()
	_tiku.ALL = field.NewAsterisk(tableName)
	_tiku.ID = field.NewInt32(tableName, "id")
	_tiku.Question = field.NewString(tableName, "question")
	_tiku.QuestionText = field.NewString(tableName, "question_text")
	_tiku.Type = field.NewInt32(tableName, "type")
	_tiku.Options = field.NewString(tableName, "options")
	_tiku.Answer = field.NewString(tableName, "answer")
	_tiku.Plat = field.NewInt32(tableName, "plat")
	_tiku.QuestionHash = field.NewString(tableName, "question_hash")
	_tiku.Hash = field.NewString(tableName, "hash")
	_tiku.Source = field.NewInt32(tableName, "source")
	_tiku.Extra = field.NewString(tableName, "extra")

	_tiku.fillFieldMap()

	return _tiku
}

type tiku struct {
	tikuDo

	ALL          field.Asterisk
	ID           field.Int32
	Question     field.String
	QuestionText field.String // 只保留汉子数字字母，方便模糊匹配
	Type         field.Int32
	Options      field.String
	Answer       field.String
	Plat         field.Int32
	QuestionHash field.String // 只有问题的短hash
	Hash         field.String // 整个实体的hash,防止重复
	Source       field.Int32  // 0采集1自建2文件类
	Extra        field.String // 扩展字段,多用于tag

	fieldMap map[string]field.Expr
}

func (t tiku) Table(newTableName string) *tiku {
	t.tikuDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tiku) As(alias string) *tiku {
	t.tikuDo.DO = *(t.tikuDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tiku) updateTableName(table string) *tiku {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt32(table, "id")
	t.Question = field.NewString(table, "question")
	t.QuestionText = field.NewString(table, "question_text")
	t.Type = field.NewInt32(table, "type")
	t.Options = field.NewString(table, "options")
	t.Answer = field.NewString(table, "answer")
	t.Plat = field.NewInt32(table, "plat")
	t.QuestionHash = field.NewString(table, "question_hash")
	t.Hash = field.NewString(table, "hash")
	t.Source = field.NewInt32(table, "source")
	t.Extra = field.NewString(table, "extra")

	t.fillFieldMap()

	return t
}

func (t *tiku) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tiku) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 11)
	t.fieldMap["id"] = t.ID
	t.fieldMap["question"] = t.Question
	t.fieldMap["question_text"] = t.QuestionText
	t.fieldMap["type"] = t.Type
	t.fieldMap["options"] = t.Options
	t.fieldMap["answer"] = t.Answer
	t.fieldMap["plat"] = t.Plat
	t.fieldMap["question_hash"] = t.QuestionHash
	t.fieldMap["hash"] = t.Hash
	t.fieldMap["source"] = t.Source
	t.fieldMap["extra"] = t.Extra
}

func (t tiku) clone(db *gorm.DB) tiku {
	t.tikuDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tiku) replaceDB(db *gorm.DB) tiku {
	t.tikuDo.ReplaceDB(db)
	return t
}

type tikuDo struct{ gen.DO }

type ITikuDo interface {
	gen.SubQuery
	Debug() ITikuDo
	WithContext(ctx context.Context) ITikuDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITikuDo
	WriteDB() ITikuDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITikuDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITikuDo
	Not(conds ...gen.Condition) ITikuDo
	Or(conds ...gen.Condition) ITikuDo
	Select(conds ...field.Expr) ITikuDo
	Where(conds ...gen.Condition) ITikuDo
	Order(conds ...field.Expr) ITikuDo
	Distinct(cols ...field.Expr) ITikuDo
	Omit(cols ...field.Expr) ITikuDo
	Join(table schema.Tabler, on ...field.Expr) ITikuDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITikuDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITikuDo
	Group(cols ...field.Expr) ITikuDo
	Having(conds ...gen.Condition) ITikuDo
	Limit(limit int) ITikuDo
	Offset(offset int) ITikuDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITikuDo
	Unscoped() ITikuDo
	Create(values ...*entity.Tiku) error
	CreateInBatches(values []*entity.Tiku, batchSize int) error
	Save(values ...*entity.Tiku) error
	First() (*entity.Tiku, error)
	Take() (*entity.Tiku, error)
	Last() (*entity.Tiku, error)
	Find() ([]*entity.Tiku, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.Tiku, err error)
	FindInBatches(result *[]*entity.Tiku, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*entity.Tiku) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITikuDo
	Assign(attrs ...field.AssignExpr) ITikuDo
	Joins(fields ...field.RelationField) ITikuDo
	Preload(fields ...field.RelationField) ITikuDo
	FirstOrInit() (*entity.Tiku, error)
	FirstOrCreate() (*entity.Tiku, error)
	FindByPage(offset int, limit int) (result []*entity.Tiku, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITikuDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tikuDo) Debug() ITikuDo {
	return t.withDO(t.DO.Debug())
}

func (t tikuDo) WithContext(ctx context.Context) ITikuDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tikuDo) ReadDB() ITikuDo {
	return t.Clauses(dbresolver.Read)
}

func (t tikuDo) WriteDB() ITikuDo {
	return t.Clauses(dbresolver.Write)
}

func (t tikuDo) Session(config *gorm.Session) ITikuDo {
	return t.withDO(t.DO.Session(config))
}

func (t tikuDo) Clauses(conds ...clause.Expression) ITikuDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tikuDo) Returning(value interface{}, columns ...string) ITikuDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tikuDo) Not(conds ...gen.Condition) ITikuDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tikuDo) Or(conds ...gen.Condition) ITikuDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tikuDo) Select(conds ...field.Expr) ITikuDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tikuDo) Where(conds ...gen.Condition) ITikuDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tikuDo) Order(conds ...field.Expr) ITikuDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tikuDo) Distinct(cols ...field.Expr) ITikuDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tikuDo) Omit(cols ...field.Expr) ITikuDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tikuDo) Join(table schema.Tabler, on ...field.Expr) ITikuDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tikuDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITikuDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tikuDo) RightJoin(table schema.Tabler, on ...field.Expr) ITikuDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tikuDo) Group(cols ...field.Expr) ITikuDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tikuDo) Having(conds ...gen.Condition) ITikuDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tikuDo) Limit(limit int) ITikuDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tikuDo) Offset(offset int) ITikuDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tikuDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITikuDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tikuDo) Unscoped() ITikuDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tikuDo) Create(values ...*entity.Tiku) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tikuDo) CreateInBatches(values []*entity.Tiku, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tikuDo) Save(values ...*entity.Tiku) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tikuDo) First() (*entity.Tiku, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*entity.Tiku), nil
	}
}

func (t tikuDo) Take() (*entity.Tiku, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*entity.Tiku), nil
	}
}

func (t tikuDo) Last() (*entity.Tiku, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*entity.Tiku), nil
	}
}

func (t tikuDo) Find() ([]*entity.Tiku, error) {
	result, err := t.DO.Find()
	return result.([]*entity.Tiku), err
}

func (t tikuDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.Tiku, err error) {
	buf := make([]*entity.Tiku, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tikuDo) FindInBatches(result *[]*entity.Tiku, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tikuDo) Attrs(attrs ...field.AssignExpr) ITikuDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tikuDo) Assign(attrs ...field.AssignExpr) ITikuDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tikuDo) Joins(fields ...field.RelationField) ITikuDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tikuDo) Preload(fields ...field.RelationField) ITikuDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tikuDo) FirstOrInit() (*entity.Tiku, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*entity.Tiku), nil
	}
}

func (t tikuDo) FirstOrCreate() (*entity.Tiku, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*entity.Tiku), nil
	}
}

func (t tikuDo) FindByPage(offset int, limit int) (result []*entity.Tiku, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tikuDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tikuDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tikuDo) Delete(models ...*entity.Tiku) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tikuDo) withDO(do gen.Dao) *tikuDo {
	t.DO = *do.(*gen.DO)
	return t
}
